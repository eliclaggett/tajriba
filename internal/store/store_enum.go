// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package store

import (
	"fmt"
	"strings"
)

const (
	// NoCompression is a Compression of type NoCompression.
	NoCompression Compression = iota
)

const _CompressionName = "NoCompression"

var _CompressionNames = []string{
	_CompressionName[0:13],
}

// CompressionNames returns a list of possible string values of Compression.
func CompressionNames() []string {
	tmp := make([]string, len(_CompressionNames))
	copy(tmp, _CompressionNames)
	return tmp
}

var _CompressionMap = map[Compression]string{
	NoCompression: _CompressionName[0:13],
}

// String implements the Stringer interface.
func (x Compression) String() string {
	if str, ok := _CompressionMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Compression(%d)", x)
}

var _CompressionValue = map[string]Compression{
	_CompressionName[0:13]:                  NoCompression,
	strings.ToLower(_CompressionName[0:13]): NoCompression,
}

// ParseCompression attempts to convert a string to a Compression.
func ParseCompression(name string) (Compression, error) {
	if x, ok := _CompressionValue[name]; ok {
		return x, nil
	}
	return Compression(0), fmt.Errorf("%s is not a valid Compression, try [%s]", name, strings.Join(_CompressionNames, ", "))
}

// MarshalText implements the text marshaller method.
func (x Compression) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Compression) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCompression(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// JSON is a Encoding of type JSON.
	JSON Encoding = iota
)

const _EncodingName = "JSON"

var _EncodingNames = []string{
	_EncodingName[0:4],
}

// EncodingNames returns a list of possible string values of Encoding.
func EncodingNames() []string {
	tmp := make([]string, len(_EncodingNames))
	copy(tmp, _EncodingNames)
	return tmp
}

var _EncodingMap = map[Encoding]string{
	JSON: _EncodingName[0:4],
}

// String implements the Stringer interface.
func (x Encoding) String() string {
	if str, ok := _EncodingMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Encoding(%d)", x)
}

var _EncodingValue = map[string]Encoding{
	_EncodingName[0:4]:                  JSON,
	strings.ToLower(_EncodingName[0:4]): JSON,
}

// ParseEncoding attempts to convert a string to a Encoding.
func ParseEncoding(name string) (Encoding, error) {
	if x, ok := _EncodingValue[name]; ok {
		return x, nil
	}
	return Encoding(0), fmt.Errorf("%s is not a valid Encoding, try [%s]", name, strings.Join(_EncodingNames, ", "))
}

// MarshalText implements the text marshaller method.
func (x Encoding) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Encoding) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseEncoding(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// Scope is a Kind of type Scope.
	Scope Kind = iota
	// Step is a Kind of type Step.
	Step
	// Attribute is a Kind of type Attribute.
	Attribute
	// Participant is a Kind of type Participant.
	Participant
	// User is a Kind of type User.
	User
	// Link is a Kind of type Link.
	Link
	// Transition is a Kind of type Transition.
	Transition
	// Service is a Kind of type Service.
	Service
	// Session is a Kind of type Session.
	Session
	// Group is a Kind of type Group.
	Group
)

const _KindName = "ScopeStepAttributeParticipantUserLinkTransitionServiceSessionGroup"

var _KindNames = []string{
	_KindName[0:5],
	_KindName[5:9],
	_KindName[9:18],
	_KindName[18:29],
	_KindName[29:33],
	_KindName[33:37],
	_KindName[37:47],
	_KindName[47:54],
	_KindName[54:61],
	_KindName[61:66],
}

// KindNames returns a list of possible string values of Kind.
func KindNames() []string {
	tmp := make([]string, len(_KindNames))
	copy(tmp, _KindNames)
	return tmp
}

var _KindMap = map[Kind]string{
	Scope:       _KindName[0:5],
	Step:        _KindName[5:9],
	Attribute:   _KindName[9:18],
	Participant: _KindName[18:29],
	User:        _KindName[29:33],
	Link:        _KindName[33:37],
	Transition:  _KindName[37:47],
	Service:     _KindName[47:54],
	Session:     _KindName[54:61],
	Group:       _KindName[61:66],
}

// String implements the Stringer interface.
func (x Kind) String() string {
	if str, ok := _KindMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Kind(%d)", x)
}

var _KindValue = map[string]Kind{
	_KindName[0:5]:                    Scope,
	strings.ToLower(_KindName[0:5]):   Scope,
	_KindName[5:9]:                    Step,
	strings.ToLower(_KindName[5:9]):   Step,
	_KindName[9:18]:                   Attribute,
	strings.ToLower(_KindName[9:18]):  Attribute,
	_KindName[18:29]:                  Participant,
	strings.ToLower(_KindName[18:29]): Participant,
	_KindName[29:33]:                  User,
	strings.ToLower(_KindName[29:33]): User,
	_KindName[33:37]:                  Link,
	strings.ToLower(_KindName[33:37]): Link,
	_KindName[37:47]:                  Transition,
	strings.ToLower(_KindName[37:47]): Transition,
	_KindName[47:54]:                  Service,
	strings.ToLower(_KindName[47:54]): Service,
	_KindName[54:61]:                  Session,
	strings.ToLower(_KindName[54:61]): Session,
	_KindName[61:66]:                  Group,
	strings.ToLower(_KindName[61:66]): Group,
}

// ParseKind attempts to convert a string to a Kind.
func ParseKind(name string) (Kind, error) {
	if x, ok := _KindValue[name]; ok {
		return x, nil
	}
	return Kind(0), fmt.Errorf("%s is not a valid Kind, try [%s]", name, strings.Join(_KindNames, ", "))
}

// MarshalText implements the text marshaller method.
func (x Kind) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Kind) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseKind(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
